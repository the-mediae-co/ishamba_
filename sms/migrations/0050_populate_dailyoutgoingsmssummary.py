# Generated by Django 2.2.24 on 2021-11-12 17:13

import time as perftime
import datetime
from decimal import Decimal

from django.db import migrations
from django.conf import settings
from django.utils import timezone

import logging

from sms.constants import OUTGOING_SMS_TYPE
logger = logging.getLogger(__name__)

# Copied from SMSRecipient.FAILED_STATUSES
FAILED_STATUSES = ['Rejected', 'Failed']


def daterange(start_date, end_date):
    """ Produce a sequence of dates (forward or backwards), inclusive of both ends """
    backwards = start_date > end_date
    delta = abs((start_date - end_date).days) + 1  # To make the dates range inclusive
    if backwards:
        seq_range = range(0, -delta, -1)
    else:
        seq_range = range(0, delta, 1)  # dates, inclusive
    for n in seq_range:
        yield start_date + datetime.timedelta(n)


def populate_dailyoutgoingsmssummary(apps, schema_editor):
    logger.setLevel(logging.DEBUG)
    settings.LOGGING['loggers']['django'] = {'level': 'DEBUG', 'handlers': ['console']}

    db_alias = schema_editor.connection.alias
    OutgoingSMS = apps.get_model("sms", "OutgoingSMS")  # NOQA
    SMSRecipient = apps.get_model("sms", "SMSRecipient")  # NOQA
    User = apps.get_model("auth", "User")  # NOQA
    DailyOutgoingSMSSummary = apps.get_model("sms", "DailyOutgoingSMSSummary")  # NOQA
    Border = apps.get_model("world", "Border")  # NOQA

    chunk_size = 5000
    outs = OutgoingSMS.objects.using(db_alias).exclude(time_sent=None).order_by('time_sent').iterator(chunk_size=chunk_size)

    first_day = datetime.date(2015, 2, 6)
    today = timezone.now().date()

    kenya_id = Border.objects.get(level=0, name="Kenya").id

    created_count = 0
    updated_count = 0

    tic = perftime.perf_counter()

    # We create distinct objects for each country/day/gateway_name/message_type combination
    for day in daterange(today, first_day):  # backwards, inclusive of both ends

        print(f"*** Summarizing {db_alias} {day}")

        for type_obj in OUTGOING_SMS_TYPE:
            msg_type = type_obj.value
            if msg_type == '?':
                continue
            t1 = perftime.perf_counter()
            message_ids = list(OutgoingSMS.objects.filter(created__date=day,
                                                          message_type=msg_type) \
                               .values_list('id', flat=True))
            if not message_ids:
                print(f"Skipping {msg_type}: no records")
                continue
            message_ids.sort()
            t2 = perftime.perf_counter()
            costs = SMSRecipient.objects.filter(message_id__in=message_ids,
                                                gateway_name='AfricasTalking').values_list('cost', flat=True)
            count = costs.count()
            t3 = perftime.perf_counter()
            # Hard code to be kenya shillings, since all messages were sent via AT in Kenya so far
            cost_units = 'kes'
            total_cost = sum(map(Decimal, costs))
            t4 = perftime.perf_counter()

            obj, created = DailyOutgoingSMSSummary.objects.update_or_create(
                date=day,
                country_id=kenya_id,
                message_type=msg_type,
                defaults={
                    'gateway_name': 'AfricasTalking',
                    'count': count,
                    'cost': total_cost,
                    'cost_units': cost_units,
                    'extra': {'message_ids': message_ids}
                }
            )
            if created:
                created_count += 1
            else:
                updated_count += 1
            t5 = perftime.perf_counter()
            print(
                f"{msg_type}: t2-t1={t2 - t1:0.1f}, t3-t2={t3 - t2:0.1f}, t4-t3={t4 - t3:0.1f}, t5-t4={t5 - t4:0.1f}")

    toc = perftime.perf_counter()
    print(f"Created {created_count} and updated {updated_count} DailyOutgoingSMSSummary "
          f"objects in {toc - tic:0.1f}s")


def remove_dailyoutgoingsmssummary(apps, schema_editor):
    """
    The reverse operation here is really not necessary this migration will
    usually accompany the prior migration which deletes the table entirely.
    However, for testing purposes, it's handy to have the ability to remove
    all records quickly.
    """
    tic = perftime.perf_counter()
    with schema_editor.connection.cursor() as cursor:
        sql = f"DELETE FROM {schema_editor.connection.schema_name}.sms_dailyoutgoingsmssummary"  # NOQA
        cursor.execute(sql, )
    toc = perftime.perf_counter()
    logger.debug(f"Done removing DailyOutgoingSMSSummary records in {toc - tic:0.1f}s")


class Migration(migrations.Migration):

    dependencies = [
        ('sms', '0049_dailyoutgoingsmssummary'),
        ('auth', '0011_update_proxy_permissions'),
    ]

    operations = [
        migrations.RunPython(populate_dailyoutgoingsmssummary, reverse_code=remove_dailyoutgoingsmssummary),
    ]
