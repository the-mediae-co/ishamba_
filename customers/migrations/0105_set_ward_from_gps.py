# Generated by Django 2.2.24 on 2021-12-05 21:26
import time

from django.db import migrations
from django.conf import settings
from django.contrib.gis.db.models.functions import Distance

import logging
logger = logging.getLogger(__name__)


def update_ward_mappings(apps, schema_editor):
    db = settings.DATABASES['default']
    db_name = db.get('NAME')
    db_schema = db.get('SCHEMA')
    db_alias = schema_editor.connection.alias

    logger.setLevel(logging.INFO)
    settings.LOGGING['loggers']['django'] = {'level': 'INFO', 'handlers': ['console']}

    Customer = apps.get_model("customers", "Customer")  # NOQA
    Border = apps.get_model("world", "Border")  # NOQA

    updated_count = 0
    customer_count = 0

    # Work on Kenya customers only
    kenya = Border.objects.get(country='Kenya', level=0)

    objs = []
    tic = time.perf_counter()
    # Find all (Kenya) customers with a gps location
    for c in Customer.objects.filter(location__isnull=False,
                                     country=kenya).only('id',
                                                         'county',
                                                         'subcounty',
                                                         'ward',
                                                         'location').iterator(chunk_size=5000):
        customer_count += 1
        if customer_count % 5000 == 0:
            # After each iterator batch, save the updates
            Customer.objects.bulk_update(objs, ['county', 'subcounty', 'ward'])
            updated_count += len(objs)
            objs = []
            toc = time.perf_counter()
            delta = toc - tic
            logger.info(f"{customer_count} customers updated in {delta:0.1f} seconds. {customer_count/delta:0.1f}/s")

        update_customer = False

        ### COUNTY ###
        try:
            county = Border.objects.get(country='Kenya', level=1, border__intersects=c.location)
        except Border.DoesNotExist:
            # Find the closest county to the customer's location that is within the county from above.
            # The logic here is that the gps location is set via the closest primary school to the farmer.
            # In many (~10,400) cases, the farmer reports that she lives just across the border in a
            # different county. So we try to find the closest county, subcounty and ward to her location.
            closest = Border.objects.filter(country='Kenya', level=1)\
                .annotate(distance=Distance('border', c.location)).order_by('distance').first()

            logger.warning(f"COUNTY NOT FOUND FOR LOCATION: schema:{db_schema} - customer:{c.id}, location:{c.location}. "
                           f"Setting county = {closest.name}")

            county = closest

        # If the customer had a county set, keep it
        if c.county and county != c.county:
            # Assume that the existing county for the customer is more accurate than the gps location
            logger.debug(f"COUNTY MISMATCH: schema:{db_schema} - customer:{c.id}, c.county:{c.county.name}, "
                         f"gps.county:{county.name}")
            county = c.county
        # If the customer had no county set, use the one that we found
        if county and not c.county:
            c.county = county
            update_customer = True

        ### SUBCOUNTY ###
        try:
            # Find a subcounty that is within the county from above and contains the customer's location
            subcounty = Border.objects.get(country='Kenya', level=2, parent=county,
                                           border__intersects=c.location)
        except Border.DoesNotExist:
            # Find the closest subcounty to the customer's location that is within the county from above.
            # The logic here is that the gps location is set via the closest primary school to the farmer.
            # In many (~10,400) cases, the farmer reports that she lives just across the border in a
            # different county. So we try to find the closest county, subcounty and ward to her location.
            # There is a vulnerability here if our maps do not have a subcounty or ward near her location
            # in the county.
            closest = Border.objects.filter(country='Kenya', level=2, parent=county,)\
                .annotate(distance=Distance('border', c.location)).order_by('distance').first()

            output = f"SUBCOUNTY NOT FOUND FOR COUNTY/LOCATION: schema:{db_schema} - customer:{c.id}, "\
                     f"county: {c.county.name}, location:{c.location}."

            if closest:
                output += f" Setting subcounty = {closest.name}"
                logger.debug(output)
            else:
                logger.warning(output)

            subcounty = closest  # Can be None

        # If the customer had a county set, keep it
        if c.subcounty and subcounty != c.subcounty:
            logger.debug(f"SUBCOUNTY MISMATCH: schema:{db_schema} - customer:{c.id}, c.subcounty:{c.subcounty.name}, "
                         f"gps.subcounty:{subcounty.name if subcounty else None}")
            subcounty = c.subcounty
        # If the customer had no subcounty set, use the one that we found
        if subcounty and not c.subcounty:
            c.subcounty = subcounty
            update_customer = True

        ### WARD ###
        try:
            # Find a ward that is within the subcounty from above and closest to the customer's location
            ward = Border.objects.get(country='Kenya', level=3, parent=subcounty,
                                      border__intersects=c.location)
        except Border.DoesNotExist:
            # Find the closest ward to the customer's location that is within the county from above.
            # The logic here is that the gps location is set via the closest primary school to the farmer.
            # In many (~10,400) cases, the farmer reports that she lives just across the border in a
            # different county. So we try to find the closest county, subcounty and ward to her location.
            # There is a vulnerability here if our maps do not have a ward or ward near her location
            # in the subcounty.
            closest = Border.objects.filter(country='Kenya', level=3, parent=subcounty)\
                .annotate(distance=Distance('border', c.location)).order_by('distance').first()

            if not closest:
                # If we could not find one in the subcounty, see if we have one within the same county
                closest = Border.objects.filter(country='Kenya', level=3, parent__parent=county) \
                    .annotate(distance=Distance('border', c.location)).order_by('distance').first()

            output = f"WARD NOT FOUND FOR COUNTY/SUBCOUNTY/LOCATION: schema:{db_schema} - customer:{c.id}, " \
                     f"county: {c.county.name}, subcounty: {c.subcounty.name}, location:{c.location}."

            if closest:
                output += f" Setting ward = {closest.name}"
                logger.debug(output)
            else:
                logger.warning(output)

            ward = closest  # Can be None

        # If the customer had a ward set, keep it
        if c.ward and ward != c.ward:
            logger.debug(f"WARD MISMATCH: schema:{db_schema} - customer:{c.id}, c.ward:{c.ward.name}, "
                         f"gps.ward:{ward.name if ward else None}")
            ward = c.ward
        # If the customer had no ward set, use the one that we found (can be None)
        if ward and not c.ward:
            c.ward = ward
            update_customer = True

        county = subcounty = ward = output = None

        if update_customer:
            objs.append(c)

    Customer.objects.bulk_update(objs, ['county', 'subcounty', 'ward'])
    updated_count += len(objs)

    toc = time.perf_counter()
    delta = toc - tic
    logger.info(f"{customer_count} customers updated in {delta:0.1f} seconds. {customer_count / delta:0.1f}/s")
    print(f"TOTAL: {updated_count} customers updated for schema {db_schema}")


class Migration(migrations.Migration):
    atomic = False
    dependencies = [
        ('customers', '0104_remove_old_location_fields'),
        ('world', '0009_populate_borders'),
    ]

    operations = [
        migrations.RunPython(update_ward_mappings, migrations.RunPython.noop),
    ]
