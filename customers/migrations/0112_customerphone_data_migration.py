# Generated by Django 3.2.14 on 2022-08-19 17:45

from django.db import migrations
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured

from digifarm.constants import DIGIFARM_PHONE_NUMBER_PREFIX
from sms.constants import KENYA_COUNTRY_CODE, UGANDA_COUNTRY_CODE

import logging
logger = logging.getLogger(__name__)


def forward_map_phone_numbers(apps, schema_editor):
    db = settings.DATABASES['default']
    db_name = db.get('NAME')
    db_schema = db.get('SCHEMA')
    db_engine = db.get('ENGINE')
    db_alias = schema_editor.connection.alias

    if db_engine != 'django_tenants.postgresql_backend':
        raise ImproperlyConfigured('The SQL queries in this migration only work with postgresql')

    logger.setLevel(logging.INFO)
    settings.LOGGING['loggers']['django'] = {'level': 'INFO', 'handlers': ['console']}

    Customer = apps.get_model("customers", "Customer")  # NOQA
    CustomerPhone = apps.get_model("customers", "CustomerPhone")  # NOQA

    # There are some malformed customers in the database that are digifarm customers, marked
    # with the category Duplicate because they also have a non-digifarm record. Previously,
    # these have had their phone number mangled by replacing '+254' with '+245' (Guinea-Bissau).
    # These should be converted fine in the logic below. These duplicate records will eventually
    # be merged and removed.

    # For all customers (including Uganda), create a CustomerPhone for their
    # non-DF 'phone' field number and mark it as main.
    with schema_editor.connection.cursor() as cursor:
        sql = f"INSERT INTO {schema_editor.connection.schema_name}.customers_customerphone(number, is_main, customer_id) " \
              f"SELECT phone, True, id FROM {schema_editor.connection.schema_name}.customers_customer " \
              f"    WHERE phone NOT LIKE '{DIGIFARM_PHONE_NUMBER_PREFIX}%';"
        cursor.execute(sql, )

    # For non-DF customers, if they have a different africas_talking_phone, create a CustomerPhone
    # record for this as well, and mark it as non-main.
    with schema_editor.connection.cursor() as cursor:
        sql = f"INSERT INTO {schema_editor.connection.schema_name}.customers_customerphone(number, is_main, customer_id) " \
              f"SELECT africas_talking_phone, False, id FROM {schema_editor.connection.schema_name}.customers_customer " \
              f"    WHERE phone NOT LIKE '{DIGIFARM_PHONE_NUMBER_PREFIX}%' " \
              f"    AND africas_talking_phone IS NOT NULL " \
              f"    AND phone <> africas_talking_phone;"
        cursor.execute(sql, )

    # For DF customers, create a CustomerPhone for their africas_talking_number and mark it as their main.
    with schema_editor.connection.cursor() as cursor:
        sql = f"INSERT INTO {schema_editor.connection.schema_name}.customers_customerphone(number, is_main, customer_id) " \
              f"SELECT africas_talking_phone, True, id FROM {schema_editor.connection.schema_name}.customers_customer " \
              f"WHERE phone LIKE '{DIGIFARM_PHONE_NUMBER_PREFIX}%' " \
              f"    AND africas_talking_phone IS NOT NULL;"
        cursor.execute(sql, )

    # For DF customers, create a CustomerPhone for their fake german number and mark it as non-main.
    # with schema_editor.connection.cursor() as cursor:
    #     sql = f"INSERT INTO {schema_editor.connection.schema_name}.customers_customerphone(number, is_main, customer_id) " \
    #           f"SELECT phone, False, id FROM {schema_editor.connection.schema_name}.customers_customer " \
    #           f"    WHERE phone LIKE '{DIGIFARM_PHONE_NUMBER_PREFIX}%';"
    #     cursor.execute(sql, )


def reverse_map_phone_numbers(apps, schema_editor):
    db = settings.DATABASES['default']
    db_name = db.get('NAME')
    db_schema = db.get('SCHEMA')
    db_alias = schema_editor.connection.alias

    logger.setLevel(logging.INFO)
    settings.LOGGING['loggers']['django'] = {'level': 'INFO', 'handlers': ['console']}

    Customer = apps.get_model("customers", "Customer")  # NOQA

    # For DF customers, if they have a fake german number, move it to the the phone field
    with schema_editor.connection.cursor() as cursor:
        sql = f"UPDATE {schema_editor.connection.schema_name}.customers_customer oc " \
              f"SET phone = cp.number " \
              f"    FROM (SELECT cp.* FROM {schema_editor.connection.schema_name}.customers_customerphone cp " \
              f"        WHERE cp.number LIKE '{DIGIFARM_PHONE_NUMBER_PREFIX}%' " \
              f"        AND cp.is_main = False) cp " \
              f"WHERE cp.number IS NOT NULL " \
              f"    AND cp.customer_id = oc.id;"
        cursor.execute(sql, )

    # For DF customers, map their main Kenyan number to the africas_talking_phone field
    with schema_editor.connection.cursor() as cursor:
        sql = f"UPDATE {schema_editor.connection.schema_name}.customers_customer oc " \
              f"SET africas_talking_phone = cp.number " \
              f"   FROM (SELECT cp.* FROM {schema_editor.connection.schema_name}.customers_customerphone cp " \
              f"    WHERE cp.number LIKE '+{KENYA_COUNTRY_CODE}%' " \
              f"    AND cp.is_main = True) cp " \
              f"WHERE cp.number IS NOT NULL " \
              f"    AND cp.customer_id = oc.id;"
        cursor.execute(sql, )

    # For non-DF customers (including Ugandans), map their main number to the phone field
    with schema_editor.connection.cursor() as cursor:
        sql = f"UPDATE {schema_editor.connection.schema_name}.customers_customer oc " \
              f"SET phone = cp.number " \
              f"   FROM (SELECT cp.* FROM {schema_editor.connection.schema_name}.customers_customerphone cp " \
              f"    WHERE cp.number NOT LIKE '{DIGIFARM_PHONE_NUMBER_PREFIX}%' " \
              f"    AND cp.is_main = True) cp " \
              f"WHERE cp.number IS NOT NULL " \
              f"    AND cp.customer_id = oc.id " \
              f"    AND oc.phone NOT LIKE '{DIGIFARM_PHONE_NUMBER_PREFIX}%';"
        cursor.execute(sql, )

    # In migrations prior to 0111, there was no way to store multiple numbers per customer.
    # As a result, in this reverse migration, those will simply be dropped.


class Migration(migrations.Migration):

    dependencies = [
        ('customers', '0111_customerphone'),
    ]

    operations = [
        migrations.RunPython(forward_map_phone_numbers, reverse_map_phone_numbers),
    ]
